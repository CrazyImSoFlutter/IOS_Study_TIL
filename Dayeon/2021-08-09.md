[(이코테 2021 강의 몰아보기) 6. 다이나믹 프로그래밍](https://youtu.be/5Lu34WIx2Us)

- 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법 = 동적 계획법
- 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 - 완전탐색과 반대
- 탑다운(하향식), 보텀업(상향식)

### 조건

- 최적 부분 구조(Optimal Substructure) - 작은 문제의 답을 모아서 큰 문제를 해결
- 중복되는 부분 문제(Overlapping Subproblem) - 동일한 작은 문제를 반복적으로 해결

ex) 피보나치 수열

- 인접한 항들 사이의 관계식 → 점화식으로 표현
- 배열이나 리스트 이용

```python
# 재귀함수로 피보나치 수열 구현
def fibo(x):
	if x == 1 or x == 2: # 재귀 종료조건
		return 1
	return fibo(x-1) + fibo(x-2)

print(fibo(4))  # 3
```

- 동일한 함수가 여러번 중복되어 호출, 시간 복잡도 O(2^N)

### 메모이제이션(Memoization) = 탑다운 = 하향식

- 한번 계산한 결과를 메모리 공간에 메모 memo = 캐싱(Cashing)
- 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
- 다이나믹 프로그램에 국한된 개념은 아님, 계산 결과를 저장하면 메모이제이션이라고 부름
- 시간 복잡도 O(N)

```python
d = [0] * 100 # 계산된 결과를 Memoization하기 위한 리스트 초기화

def fibo(x): 
	if x == 1 or x == 2: # 재귀 종료조건
		return 1
	if d[x] != 0: # 이미 계산한 적 있는 문제면 그대로 반환
		return d[x]
	d[x] = fibo(x-1) + fibo(x-2)
	return d[x]
```

### 보텀업 = 상향식

- DP의 전형적인 형식
- 결과 저장용 리스트는 DP 테이블이라고 부름

```python
d = [0] * 100 # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화

d[1] = 1 # 가장 작은 문제 
d[2] = 1
n = 99

# 반복문으로 구현 - 가장 작은 문제부터 조합해서 큰 문제 계산
for i in range(3, n+1):
	d[i] = d[i-1]  + d[i-2]
```

### 분할정복(퀵 정렬)과 비교

- 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 '최적 부분 구조'를 가질 때 DP와 분할 정복사용
- 차이점은 부분 문제의 중복!
- DP는 각 부분 문제들이 서로 영향을 미치고 중복된다
- 분할 정복은 동일 부분 문제가 중복되어 계산되지 않음
- 퀵 정렬 - 한번 기준 원소(Pivot)가 자리를 변경해서 자리를 잡으면(분할 완료) 그 위치는 바뀌지 않는다

### DP 문제 접근 방법

- 그리디, 구현, 완전 탐색으로 해결할 수 있는지 검토
- 일단 재귀 함수로 완전 탐색 프로그램을 작성한 뒤 탑다운(작은 문제에서 구한 답이 큰 문제에 사용될 수 있도록)으로 코드 개선
