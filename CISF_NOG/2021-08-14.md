# 2021_08_14_TIL

<오버플로우 연산, 백준 1456번>

C Family는 현재 자료형보다 더 큰 값이 들어오게 되면 자동으로 오버플로우 연산에 들어간다.

오버플로우는 원순환과 같아서 초과된 범위만큼 가장 작은 값부터 다시 증가하게 되는데,

C Family에서는 이를 컴파일 에러나 런타임 에러 취급하지 않고 하나의 연산으로 보기 때문에 문제를 풀 때 상당히 불편한 부분이 많았다.

오버플로우가 일어나면 거의 무조건 값이 틀리기 때문에 오답 처리를 해줘야 하는데 명시적으로 보이지 않으니 틀렸는 지 체크하기가 힘들다.

그러나 Swift에서는 이걸 자동으로 잡아주고, 런타임 에러 취급을 해준다.

상당히 편리한 기능이라고 생각하고 있었는데, 이것 때문에 문제를 풀다가 발목이 잡힐 줄은 몰랐다...

사실은 기능에는 잘못이 없다.

근데 문제는 내가 오버플로우 연산을 하고 싶은데, 하는 방법을 몰랐다는 것이다.

지금까지 C에서는 다 자동으로 됐는데, 여기선 내가 수동으로 조작해야하고 지금까지 내가 수동으로 조작해본 적이 없었기 때문이다.

그래서 한참의 구글링을 통해 방법을 찾아냈다.

```swift
var i = 100
var a = i * i
```

기존의 연산은 이런 식으로 이루어진다.

하지만 이는 오버플로우 연산이 기본 옵션이 아니다.

오버플로우 연산을 수동적으로 체크해주고 싶다면,

'&' 기호를 연산자 앞에 사용하면 된다.

```swift
var i = 100000000000
var a = i &* i
```

이렇게 하면 오버플로우 연산이 되어 런타임 에러가 일어나지 않는다.

그렇다면 오버플로우가 일어났는지는 어떻게 체크할까?

간단한 수학적 방식이 있다.

오버플로우가 일어나면 완전히 다른 수가 되기때문에 덧셈이나 뺄셈의 경우 반대의 연산을 다시 한 번 해보면 되고,

곱셈의 경우에는 나머지 연산을 해보면 된다.

```swift
var i = 100000000000
var a = 999999999999

a = a &* i

if a % i != 0 { print("OVERFLOWED!!") }
```
