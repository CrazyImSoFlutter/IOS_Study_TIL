# 2021_08_08_TIL

<lis의 응용>

lis의 기본적인 알고리즘은 이렇다.

두 개의 인덱스가 배열을 돈다.

첫번째 인덱스를 i라고 하고 두번째 인덱스를 j라고 하자.

i번째의 값을 기준으로 진행이 된다.

j는 0부터 i번까지 진행된다.

일단은 i번째의 값을 알아낸다.

그리고 j인덱스의 순회가 시작되는데,

이 때 i번째 값보다 j번째 값이 작다면 dp배열에서 dp[i] = dp[j] + 1로 값이 갱신된다.

이 것은 i번째 값보다 작으면서 증가하는 수를 메모해놓는 것이다.

1 5 2 1 4 3 4 5 2 1 이라는 배열이 있다고 해보자.

첫번째 dp는 무조건 1이다. 

두번째 dp는 첫번째 배열 값보다 두번째 배열 값이 큰 경우 첫번째 dp값 + 1이 된다. 

즉 2가 된다.

세번째 dp는 두번째 배열 값보다 세번째 값이 작으므로 앞의 1만을 포함시킬 수 있다.

즉, 앞의 값과의 비교를 통해서 값을 채우는 것이다.

현재 값이 4인데 앞에 있는 3에서 lis가 2개가 채워졌다고 하면, 

4는 3보다 크니까 3의 lis를 그대로 흡수 할 수 있는 것이다.

자신 보다 작은 값의 lis를 그대로 흡수하면서 계산하는 것이다.

여기까지가 lis이고 백준 11053번 문제다.

문제는 11054번 바이토닉 수열 문제다.

바이토닉 수열은 한 값을 기준으로 왼쪽은 증가, 오른쪽은 감소하는 형태를 지닌 수열이다.

1 2 3 5 4 3 2 1

이런 식의 수열을 말한다.

한 쪽으로만 커지거나 작아져도 상관없다.

1 2 3 4

4 3 2 1

이것도 바이토닉 수열에 포함된다.

첫인상은 조금 까다로워보였지만 lis를 떠올리니 쉬워졌다.

한 값을 기준으로 왼쪽 lis와 오른쪽 lis를 구하면 되는 것이었다.

왼쪽 끝부터 lis를 하나 구하고, 오른쪽 끝부터 lis를 하나 구해서 두 dp를 합쳐주면 된다.

그리고 합쳐진 dp중 최댓값을 구하면 최장 수열이 된다.

처음에는 굉장히 바보같이 구했는데 이는 시간초과로 이어졌다.

양 끝에서 한번씩 계산하면 될 것을, 모든 인덱스에서 각 인덱스를 기준으로 좌 우로 구해주고 있었다.

이렇게 되면 1000개라고 가정했을 때 전체 순회 한 번, 양 쪽 lis 순회 한번씩 해서 엄청난 수가 나오게 된다.

양 끝만 구해도 되는 이유는 dp의 인덱스는 그 값을 가지는 lis를 의미하기 때문이다.

dp[4]라고 하면 처음부터 4번째까지의  인덱스에서 4번째를 포함하는 lis를 의미하는 것이므로,

정방향과 역방향을 구해주면 증가 lis와 감소 lis가 각각 나오게 된다.

물론 현재 인덱스가 두번 들어가므로 한 번 빼줘야 한다.
