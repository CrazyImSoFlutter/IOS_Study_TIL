# 2021_08_26_TIL

<백준 9020번 swift 문제풀이>

## 문제

1보다 큰 자연수 중에서  1과 자기 자신을 제외한 약수가 없는 자연수를 소수라고 한다. 예를 들어, 5는 1과 5를 제외한 약수가 없기 때문에 소수이다. 하지만, 6은 6 = 2 × 3 이기 때문에 소수가 아니다.

골드바흐의 추측은 유명한 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 것이다. 이러한 수를 골드바흐 수라고 한다. 또, 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. 예를 들면, 4 = 2 + 2, 6 = 3 + 3, 8 = 3 + 5, 10 = 5 + 5, 12 = 5 + 7, 14 = 3 + 11, 14 = 7 + 7이다. 10000보다 작거나 같은 모든 짝수 n에 대한 골드바흐 파티션은 존재한다.

2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다.

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고 짝수 n이 주어진다.

## 출력

각 테스트 케이스에 대해서 주어진 n의 골드바흐 파티션을 출력한다. 출력하는 소수는 작은 것부터 먼저 출력하며, 공백으로 구분한다.

## 제한

- 4 ≤ n ≤ 10,000

## 문제 링크

[백준 9020번](https://www.acmicpc.net/problem/9020){:target="_blank"}

## 풀이

n은 짝수 이므로, 2로 나누면 나누어 떨어진다.

2로 나눈 수를 변수 a와 b에 2로 나눈 수를 하나씩 나누어준다.

그리고 a를 작은 수라고 하고 b를 큰 수라고 지정해놓고,

작은 수는 초기값으로부터 계속 -1,

큰 수는 초기값으로부터 계속 +1을 해주면서

a와 b가 둘 다 소수인지 검사하면 된다.

a와 b는 n보다 작은 모든 수가 될 수 있으므로, 짝수 n보다 작은 모든 소수를 알면 문제는 쉽게 풀린다.

그러면 소수를 구하는 방법부터 알아보자.

### 해당 수가 소수인지 판별

가장 쉬운 방법은 2부터 자기 자신 전까지 한 번씩 다 나눠보는 것이다.

그런데 조금만 생각해봐도 이 방법은 시간이 오래걸림을 알 수 있다.

**만약 10억 넘는 수가 들어온다면?**

운이 좋아서 그 수가 소수가 아니면 금방 끝나서 다행이지만, 그 수가 소수라면 10억번 연산하게 된다.

그렇다면 어떻게 해야할까?

일단 그에 대한 해답은

**해당 수의 제곱근 값까지만 연산하면 된다는 것이다.**

일단 어떠한 수는 a * b로 표현할 수 있다.

일단 a는 b보다 작다고 하자.

소수의 경우에는 1 * 자기자신 으로 나타내지겠지만, 소수가 아니라면 a가 1이 아닐 것이다.

그렇다면 a * b 를 잘 보자.

a를 1부터 시작해서 조금씩 키워나가보자.

그러면 어느 순간부터는 b보다 커지게 된다.

그때부터는 a * b의 위치가 뒤바뀌는 시점이면서, 더 이상 계산할 필요가 없는 부분이 된다.

커진 a가 지금까지 계산했던 b가 될 것이기 때문이다.

예를 들어보자,

24라는 수를 나누어 떨어지는 값 a, b로 표현을 해보겠다.

1. 1 * 24 = 24
2. 2 * 12 = 24
3. 3 * 8 = 24
4. 4 * 6 = 24
5. 6 * 4 = 24
6. 8 * 3 = 24
7. 12 * 2 = 24
8. 24 * 1 = 24

4번과 5번 사이의 인덱스를 중심으로 좌우 대칭된 걸 볼 수 있다.

이 말은 어떤 수 n의 제곱근 값까지만으로도 나눠도 약수를 다 구할 수 있다는 것이다.

즉, n의 제곱근 값 전에 (1제외) 나누어 떨어지는 값이 있다면 소수가 아닌것이다.

그래서 121이 들어오면 121을 다 계산하는게 아니라 11까지만 계산해보면 된다.

### 에라토스테네스의 체

앞의 소수판별은 수 한개를 대상으로 한 것이라면, 이 에라토스테네스의 체는 범위 내의 소수를 모두 구하는 방법이다.

#### 알고리즘

1. 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다.

   ![IMG_4B69BED24B07-1](https://user-images.githubusercontent.com/65299607/130922169-7a99bd1c-fc45-4327-851a-9ed593515917.jpeg)

2. 2는 소수 이므로 2를 써준다.

   ![IMG_3B9FE96D8F03-1](https://user-images.githubusercontent.com/65299607/130922179-30991ac4-f631-4d07-ac79-b1a4b54f9d04.jpeg)

3. 자기 자신을 제외한 2의 배수를 모두 지운다.

   ![IMG_B03723132A0B-1](https://user-images.githubusercontent.com/65299607/130922187-d8051729-6f77-4184-9b4d-807b9480797f.jpeg)

4. 남아 있는 수 가운데 3은 소수이므로 3을 써준다.

   ![IMG_A8DB4E03B84C-1](https://user-images.githubusercontent.com/65299607/130922195-e1da6dab-eed3-4ba0-9dd4-3a50311c1a85.jpeg)

5. 자기 자신을 제외한 3의 배수를 모두 지운다.

   ![IMG_06EA8989AC36-1](https://user-images.githubusercontent.com/65299607/130922209-276af264-d3fa-4213-a673-d0cc4bfef76f.jpeg)

6. 남아 있는 수 가운데 5는 소수이므로 5를 써준다.

   ![IMG_15D2E21BA176-1](https://user-images.githubusercontent.com/65299607/130922225-fac25c55-b361-4eda-acfe-aa39a3ba7668.jpeg)

7. 자기 자신을 제외한 5의 배수를 모두 지운다.

   ![IMG_F8BDCF000549-1](https://user-images.githubusercontent.com/65299607/130922241-090cb9db-fea4-4f16-9c9f-114a803cdbb2.jpeg)

8. 남아 있는 수 가운데 7은 소수이므로 7을 써준다.

   ![IMG_5B3056B20AD2-1](https://user-images.githubusercontent.com/65299607/130922262-f9f49116-f1aa-422c-a154-37b15a3125db.jpeg)

9. 자기 자신을 제외한 7의 배수를 모두 지운다.

   ![IMG_EF98947A129B-1](https://user-images.githubusercontent.com/65299607/130922271-dca3494b-02c6-4edd-9344-7ae0033dbf29.jpeg)

10. 100의 제곱근은 10이므로 10까지 반복해주는데, 7위로는 소수가 없으므로 남은 수들을 세준다. 그 수들이 소수다.

   ![IMG_7B5F0DB413CD-1](https://user-images.githubusercontent.com/65299607/130922286-7ac11ad3-69e1-4975-b221-af233bea4c1e.jpeg)

이 과정을 반복하면 구간의 모든 소수를 구할 수 있다.

### 프로그램 동작

1. n까지의 소수를 모두 구한다.

2. n을 2로 나눠서 a와 b에 넣는다.

3. a와 b 둘 다 소수인지 체크해본다.

   3-1. 둘 다 소수라면 a, b출력과 함께 종료한다.

4. 둘 중 하나라도 소수가 아닐 경우 a는 -1, b는 +1을 해서 3번을 반복한다.

## Swift 코드

```swift
let T = Int(readLine()!)!
var prime = Array(repeating: true, count: 10001)

func primeNum() {
    prime[0] = false
    prime[1] = false
    for i in 2..<10000 {
        for j in stride(from: i * 2, to: 10000, by: i) {
            prime[j] = false
        }
    }
}

func goldbach(_ a: Int, _ b: Int, _ c: Int) {
    if a < 4 || a > 10000 || a % 2 != 0 {
        return
    } else {
        if prime[b] == true && prime[c] == true {
            print(b, c)
        } else {
            goldbach(a, b - 1, c + 1)
        }
    }
}

primeNum()

for _ in 0..<T {
    let tmp = Int(readLine()!)!
    goldbach(tmp, tmp / 2, tmp / 2)
}
```

goldbach()함수에 재귀를 사용했다.

