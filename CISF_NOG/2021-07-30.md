# 2021_07_30_TIL

<동적 계획법> 

백준 1912번 문제를 풀어보았다.

동적 계획법 문제라고 해서 뭔가 재귀함수 쓰고 메모이제이션 쓰고 해야할 줄 알았는데,

굳이 그럴 필요까진? 없었던거 같다.

10만까지 입력이 들어오는데 딱 한번만 순회해도 문제를 해결 할 수 있다.

(지금 생각해보니 메모이제이션 비스무리한걸 쓰는거 같긴 하다.)

알고리즘은 이렇다.

배열에 들어있는 값들을 하나씩 받는데, 두 가지 경우로 나뉜다.

1) 값이 양수일때.

값이 양수면 일단 배열의 값들이 전부 다 음수인 것은 아니란 뜻이므로,

양수가 있다는 의미로 flag를 true로 바꿔준다.

그리고 sum이 음수라면, 현재 값으로 초기화 해준다.

이 이유는 뒤에 나온다.

그리고 sum이 양수라면, 현재 값을 더해준다.

2) 값이 음수일때.

값이 음수면 일단 가장 작은 음수인지 체크를 해본다.

만약 전부 다 음수라면, 가장 작은 음수를 출력해야하기 때문이다.

가장 작은 음수라면 일단 값을 적어놓는다.

그리고 sum이 음수라면 이번 인덱스는 그냥 스킵해버린다.

근데 sum이 양수라면 정답 값과 sum값과 비교해보고,

정답 값이 더 작다면 정답 값을 sum값으로 바꿔준 다음,

sum값에 현재 값을 더해준다.

1), 2) 과정을 모든 배열 요소에 대해 반복한다.



논리는 이렇다.

어차피 연속된 수밖에 못더하는데, 양수만 더해도 모자를 판에 음수를 더하면 값이 작아진다.

그런데 만약에 양수와 양수 사이에 음수가 껴있는 경우라면 어떨까.

첫번째 양수가 사이에 있는 음수들의 합보다 작으면 아무 상관 없는데,

첫번째 양수가 사이에 있는 음수들의 합보다 크면 첫번째 양수부터 두번째 양수부터 다 더하는게 결과적으로는 이득이란 것이다.

예시를 들어보겠다.

10 -11 -1 -2 12

이런 경우는 첫번째 양수를 버리는게 이득이다.

100 -11 -1 -2 12

하지만 이런 경우는 첫번째 양수를 버리기엔 값이 엄청나게 크다.

그래서 일단 100부터 12까지 다 더하고 보는것이다.

근데 두번째 예시는 결과적으로는 뒤의 값을 더할 필요가 없다.

이런 상황을 대비해서 음수를 더하기 전에 미리 값을 백업해놓는것이다.

값을 백업해놓고 더해봤는데 값이 더 크면 갱신하고, 값이 더 작아지면 갱신하지 않으면 되는 것이다.

이렇게 하면 모든 경우에 대해서 가장 큰 값을 한번만의 순회로 찾아낼 수 있다.
